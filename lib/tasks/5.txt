Tuple

从某种意义上讲，Tuple(元组)很像List--都是将多个值存入一个个体的容器。但它们却有着本质的不同，一组数字的List就是一组数字，它们的类型相 同，且不关心其中包含元素的数量。而Tuple则要求你对需要组合的数据的数目非常的明确，它的类型取决于其中项的数目与其各自的类型。Tuple中的项 由括号括起，并由逗号隔开。

另外的不同之处就是Tuple中的项不必为同一类型，在Tuple里可以存入多类型项的组合。

动脑筋，在haskell中表示二维向量该如何？使用List是一种方法，它倒也工作良好。若要将一组向量置于一个List中来表示平面图形又该怎样？我们可以写类似[[1,2],[8,11],[4,5]]的代码来实现。但问题在于，[[1,2],[8,11,5],[4,5]]也是同样合法的，因为其中元素的类型都相同。尽管这样并不靠谱，但编译时并不会报错。然而一个长度为2的Tuple（也可以称作序对，Pair），是一个独立的类 型，这便意味着一个包含一组序对的List不能再加入一个三元组，所以说把原先的方括号改为圆括号使用Tuple会 更好:[(1,2),(8,11),(4,5)]。若试图表示这样的图形：[(1,2),(8,11,5),(4,5)]，就会报出以下的错误：

Couldn't match expected type `(t, t1)'   
against inferred type `(t2, t3, t4)'   
In the expression: (8, 11, 5)   
In the expression: [(1, 2), (8, 11, 5), (4, 5)]   
In the definition of `it': it = [(1, 2), (8, 11, 5), (4, 5)]
这告诉我们说程序在试图将序对和三元组置于同一List中，而这是不允许的。同样[(1,2),("one",2)]这样的List也不行，因为 其中的第一个Tuple是一对数字，而第二个Tuple却成了一个字符串和一个数字。Tuple可以用来储存多个数据，如，我们要表示一个人的名字与年 龄，可以使用这样的Tuple:("Christopher", "Walken", 55)。从这个例子里也可以看出，Tuple中也可以存储List。

使用Tuple前应当事先明确一条数据中应该由多少个项。每个不同长度的Tuple都是独立的类型，所以你就不可以写个函数来给它追加元素。而唯一能做的，就是通过函数来给一个List追加序对，三元组或是四元组等内容。

可以有单元素的List，但Tuple不行。想想看，单元素的Tuple本身就只有一个值，对我们又有啥意义？不靠谱。

同List相同，只要其中的项是可比较的，Tuple也可以比较大小，只是你不可以像比较不同长度的List那样比较不同长度的Tuple。如下是两个有用的序对操作函数：

fst返回一个序对的首项。

ghci> fst (8,11)   
8   
ghci> fst ("Wow", False)   
"Wow"
snd返回序对的尾项。

ghci> snd (8,11)   
11   
ghci> snd ("Wow", False)   
False
Note：这两个函数仅对序对有效，而不能应用于三元组，四元组和五元组之上。稍后，我们将过一遍从Tuple中取数据的所有方式。
有个函数很cool，它就是zip。它可以用来生成一组序对(Pair)的List。它取两个List，然后将它们交叉配对，形成一组序对的List。它很简单，却很实用，尤其是你需要组合或是遍历两个List时。如下是个例子：

ghci> zip [1,2,3,4,5] [5,5,5,5,5]   
[(1,5),(2,5),(3,5),(4,5),(5,5)]   
ghci> zip [1 .. 5] ["one", "two", "three", "four", "five"]   
[(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]
它把元素配对并返回一个新的List。第一个元素配第一个，第二个元素配第二个..以此类推。注意，由于序对中可以含有不同的类型，zip函数可能会将不同类型的序对组合在一起。若是两个不同长度的List会怎么样？

ghci> zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"]   
[(5,"im"),(3,"a"),(2,"turtle")]
较长的那个会在中间断开，去匹配较短的那个。由于haskell是惰性的，使用zip同时处理有限和无限的List也是可以的：

ghci> zip [1..] ["apple", "orange", "cherry", "mango"]   
[(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")]
接下来考虑一个同时应用到List和Tuple的问题：如何取得所有三边长度皆为整数且小于等于10，周长为24的直角三角形？首先，把所有三遍长度小于等于10的三角形都列出来：

ghci> let triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ]
刚才我们是从三个List中取值，并且通过输出函数将其组合为一个三元组。只要在ghci下边调用triangle，你就会得到所有三边都小于等于 10的三角形。我们接下来给它添加一个限制条件，令其必须为直角三角形。同时也考虑上b边要短于斜边，a边要短于b边情况：

ghci> let rightTriangles = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2]
已经差不多了。最后修改函数，告诉它只要周长为24的三角形。

ghci> let rightTriangles' = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24]   
ghci> rightTriangles'   
[(6,8,10)]
得到正确结果！这便是函数式编程的一般思路：先取一个初始的集合并将其变形，执行过滤条件，最终取得正确的结果。