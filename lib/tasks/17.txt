lambda

lambda就是匿名函数。有些时候我们需要传给高阶函数一个函数，而这函数我们只会用这一次，这就弄个特定功能的lambda。编写lambda，就写个\（因为它看起来像是希腊字母的lambda--如果你斜视的厉害），后面是用空格分隔的参数，->后面就是函数体。通常我们都是用括号将其括起，要不然它就会占据整个右边部分。

向上5英寸左右，你会看到我们在numLongChain函数中用where语句声明了个isLong函数传递给了filter。好的，用lambda代替它。

numLongChains :: Int   
numLongChains = length (filter (\xs -> length xs > 15) (map chain [1..100]))

lambda是个表达式，因此我们可以任意传递。表达式(\xs -> length xs > 15)返回一个函数，它可以告诉我们一个list的长度是否大于15。

不熟悉柯里函数与不全调用的人们往往会写出很多lambda，而实际上大部分都是没必要的。例如，表达式map (+3) [1,6,3,2]与map (\x -> x+3) [1,6,3,2]等价，(+3)和(\x -> x+3)都是给一个数加上3。不用说，在这种情况下不用lambda要清爽的多。

和普通函数一样，lambda也可以取多个参数。

ghci> zipWith (\a b -> (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5]   
[153.0,61.5,31.0,15.75,6.6]
同普通函数一样，你也可以在lambda中使用模式匹配，只是你无法为一个参数设置多个模式，如[]和(x:xs)。lambda的模式匹配若失败，就会引发一个运行时错误，所以慎用！

ghci> map (\(a,b) -> a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)]   
[3,8,9,8,7]
一般情况下，lambda都是括在括号中，除非我们想要后面的整个语句都作为lambda的函数体。很有趣，由于有柯里化，如下的两段是等价的：

addThree :: (Num a) => a -> a -> a -> a   
addThree x y z = x + y + z
addThree :: (Num a) => a -> a -> a -> a   
addThree = \x -> \y -> \z -> x + y + z
这样的函数声明与函数体中都有->，这一来类型声明的写法就很明白了。当然第一段代码更易读，不过第二个函数使得柯里化更容易理解。

有些时候用这种语句写还是挺酷的，我觉得这应该是最易读的flip函数实现了：

flip' :: (a -> b -> c) -> b -> a -> c   
flip' f = \x y -> f y x
尽管这与flip' f x y = f y x等价，但它可以更明白地表示出它会产生一个新的函数。flip常用来处理一个函数，再将返回的新函数传递给map或filter。所以如此使用lambda可以更明确地表现出返回值是个函数，可以用来传递给其他函数作参数。