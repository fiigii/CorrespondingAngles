你好，递归！

前面的章节中我们简要谈了一下递归。而在本章，我们会深入地了解到它为何在haskell中是如此重要，能够以递归思想写出简洁优雅的代码。

如果你还不明白什么是递归，就读这个句子。哈哈！玩笑而已！递归实际上是定义函数以调用自身的方式。在数学定义中，递归随处可见，如斐波那契数列（fibonacci）。它先是定义两个非递归的数：F(0)=0,F(1)=1，表示斐波那契数列的前两个数为0和 1。然后就是对其他自然数，其斐波那契数就是它前面两个数字的和，即F(N)=F(N-1)+F(N-2)。这样一来，F(3)就是F(2)+F(1)，进一步便是(F(1)+F(0))+F(1)。已经下探到了前面定义的非递归斐波那契数，可以放心地说F(3)就是2了。在递归定义中声明的一两个非递归的值（如F(0)和F(1)）也可以称作边界条件，这对递归函数的正确求值至关重要。要是前面没有定义F(0)和F(1)的话，它下探到0之后就会进一步到负数，你就永远都得不到结果了。一不留神它就算到了F(-2000)=F(-2001)+F(-2002)，并且永远都算不到头！

递归在haskell中至关重要。命令式语言要求你提供求解的步骤，haskell则倾向于让你提供问题的描述。这便是haskell没有while或for循环的原因，递归是我们的替代方案。

麦克西米不可思议
maximum函数取一组可排序的List（属于 Ord类型类）做参数，并返回其中的最大值。想想，在命令式风格中这一函数该怎么实现。很可能你会设一个变量来存储当前的最大值，然后用循环遍历该 List，若存在比这个值更大的元素，则修改变量为这一元素的值。到最后，变量的值就是运算结果。唔！描述如此简单的算法还颇费了点口舌呢！

现在看看递归的思路是如何：我们先定下一个边缘条件，即处理单个元素的List时，返回该元素。如果该List的头部大于尾部的最大值，我们就可以假定较长 的List的最大值就是它的头部。而尾部若存在比它更大的元素，它就是尾部的最大值。就这么简单！现在，我们在haskell中实现它

maximum' :: (Ord a) => [a] -> a   
maximum' [] = error "maximum of empty list"   
maximum' [x] = x   
maximum' (x:xs)    
    | x > maxTail = x   
    | otherwise = maxTail   
    where maxTail = maximum' xs
如你所见，模式匹配与递归简直就是天造地设！大多数命令式语言中都没有模式匹配，于是你就得造一堆if-else来测试边界条件。而在这里，我们仅需要使用 模式将其表示出来。第一个模式说，如果该List为空，崩溃！就该这样，一个空List的最大值能是啥？我不知道。第二个模式也表示一个边缘条件，它说， 如果这个List仅包含单个元素，就返回该元素的值。

现在是第三个模式，执行动作的地方。 通过模式匹配，可以取得一个List的头部和尾部。这在使用递归处理List时是十分常见的。出于习惯，我们用个where语句来表示maxTail作为该List中尾部的最大值，然后检查头部是否大于尾部的最大值。若是，返回头部；若非，返回尾部的最大值。

我们取个List[2,5,1]做例子来看看它的工作原理。当调用maximum'处理它时，前两个模式不会被匹配，而第三个模式匹配了它并将其分为2与[5,1]。 where子句再取[5,1]的最大值。于是再次与第三个模式匹配，并将[5,1]分割为5和[1]。继续，where子句取[1]的最大值，这时终于到了边缘条件！返回1。进一步，将5与[1]中的最大值做比较，易得5，现在我们就得到了[5,1]的最大值。再进一步，将2与[5,1]中的最大值相比较，可得5更大，最终得5。

改用max函数会使代码更加清晰。如果你还记得，max函数取两个值做参数并返回其中较大的值。如下便是用max函数重写的maximun'

maximum' :: (Ord a) => [a] -> a   
maximum' [] = error "maximum of empty list"   
maximum' [x] = x   
maximum' (x:xs) = max x (maximum' xs)
太漂亮了！一个List的最大值就是它的首个元素与它尾部中最大值相比较所得的结果，简明扼要。


几个递归函数
现在我们已经了解了递归的思路,接下来就使用递归来实现几个函数. 先实现下replicate函数, 它取一个Int值和一个元素做参数, 返回一个包含多个重复元素的List, 如replicate 3 5返回[5,5,5]. 考虑一下, 我觉得它的边界条件应该是负数. 如果要replicate重复某元素零次, 那就是空List. 负数也是同样, 不靠谱.

replicate' :: (Num i, Ord i) => i -> a -> [a]   
replicate' n x   
    | n <= 0    = []   
    | otherwise = x:replicate' (n-1) x
在这里我们使用了门卫而非模式匹配, 是因为这里做的是布尔判断. 如果n小于0就返回一个空List, 否则, 返回以x作首个元素并后接重复n-1次x的List. 最后, (n-1)的那部分就会令函数抵达边缘条件.

Note: Num不是Ord的子集, 表示数字不一定得拘泥于排序, 这就是在做加减法比较时要将Num与Ord类型约束区别开来的原因.
接下来实现take函数, 它可以从一个List取出一定数量的元素. 如take 3 [5,4,3,2,1],得[5,4,3]. 若要取零或负数个的话就会得到一个空List. 同样, 若是从一个空List中取值, 它会得到一个空List. 注意, 这儿有两个边界条件, 写出来:

take' :: (Num i, Ord i) => i -> [a] -> [a]   
take' n _   
    | n <= 0   = []   
take' _ []     = []   
take' n (x:xs) = x : take' (n-1) xs

首个模式辨认若为0或负数, 返回空List. 同时注意这里用了一个门卫却没有指定otherwise部分, 这就表示n若大于0, 会转入下一模式. 第二个模式指明了若试图从一个空List中取值, 则返回空List. 第三个模式将List分割为头部和尾部, 然后表明从一个list中取多个元素等同于令x作头部后接从尾部取n-1个元素所得的List. 假如我们要从[4,3,2,1]中取3个元素, 试着从纸上写出它的推导过程

reverse函数简单地反转一个List, 动脑筋想一下它的边界条件! 该怎样呢? 想想...是空List! 空List的反转结果还是它自己. Okay , 接下来该怎么办? 好的, 你猜的出来. 若将一个List分割为头部与尾部, 那它反转的结果就是反转后的尾部与头部相连所得的List.

reverse' :: [a] -> [a]   
reverse' [] = []   
reverse' (x:xs) = reverse' xs ++ [x]
继续进发!

haskell支持无限List，所以我们的递归就不必添加边界条件。这样一来，它可以对某值计算个没完, 也可以产生一个无限的数据结构，如无限List。而无限List的好处就在于我们可以在任意位置将它断开.

repeat函数取一个元素作参数, 返回一个仅包含该元素的无限List. 它的递归实现简单的很, 看:

repeat' :: a -> [a]   
repeat' x = x:repeat' x
调用repeat 3会得到一个以3为头部并无限数量的3为尾部的List, 可以说repeat 3运行起来就是3:repeat 3, 然后3:3:3:3等等. 若执行repeat 3, 那它的运算永远都不会停止。而take 5 (repeat 3)就可以得到5个3, 与replicate 5 3差不多.

zip取两个List作参数并将其捆在一起。zip [1,2,3] [2,3]返回[(1,2),(2,3)], 它会把较长的List从中间断开, 以匹配较短的List. 用zip处理一个List与空List又会怎样? 嗯, 会得一个空List, 这便是我们的限制条件, 由于zip取两个参数, 所以要有两个边缘条件

zip' :: [a] -> [b] -> [(a,b)]   
zip' _ [] = []   
zip' [] _ = []   
zip' (x:xs) (y:ys) = (x,y):zip' xs ys
前两个模式表示两个List中若存在空List, 则返回空List. 第三个模式表示将两个List捆绑的行为, 即将其头部配对并后跟捆绑的尾部. 用zip处理[1,2,3]与['a','b']的话, 就会在[3]与[]时触及边界条件, 得到(1,'a'):(2,'b'):[]的结果,与[(1,'a'),(2,'b')]等价.

再实现一个标准库函数--elem! 它取一个元素与一个List作参数, 并检测该元素是否包含于此List. 而边缘条件就与大多数情况相同, 空List. 大家都知道空List中不包含任何元素, 便不必再做任何判断

elem' :: (Eq a) => a -> [a] -> Bool   
elem' a [] = False   
elem' a (x:xs)   
    | a == x    = True   
    | otherwise = a `elem'` xs
简单直接. 若头部不是该元素, 就检测尾部, 若为空List就返回False