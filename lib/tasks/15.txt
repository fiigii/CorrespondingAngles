是时候了，来点高阶函数！
haskell中的函数可以取另一个函数做参数，也可以返回函数。 举个例子，我们弄个取一个函数并调用它两次的函数.

applyTwice :: (a -> a) -> a -> a   
applyTwice f x = f (f x)

首先注意这类型声明。 在此之前我们很少用到括号，因为(->)是自然的右结合，不过在这里括号是必须的。 它标明了首个参数是个参数与返回值类型都是a的函数，第二个参数与返回值的类型也都是a。 我们可以用柯里函数的思路来理解这一函数，不过免得自寻烦恼，我们姑且直接把它看作是取两个参数返回一个值，其首个参数是个类型为(a->a)的函数,第二个参数是个a。 该函数的类型可以是(Int->Int)，也可以是(String->String)，但第二个参数必须与之一致。

Note: 现在开始我们会直说某函数含有多个参数(除非它真的只有一个参数)。 以简洁之名，我们会说(a->a->a)取两个参数，尽管我们知道它在背后做的手脚.
这个函数是相当的简单，就拿参数f当函数，用x调用它得到的结果再去调用它。 也就可以这样玩:

ghci> applyTwice (+3) 10   
16   
ghci> applyTwice (++ " HAHA") "HEY"   
"HEY HAHA HAHA"   
ghci> applyTwice ("HAHA " ++) "HEY"   
"HAHA HAHA HEY"   
ghci> applyTwice (multThree 2 2) 9   
144   
ghci> applyTwice (3:) [1]   
[3,3,1]
看，不全调用多神奇! 如果有个函数要我们给它传个一元函数，大可以不全调用一个函数让它剩一个参数，再把它交出去。

接下来我们用高阶函数的编程思想来实现个标准库中的函数，它就是zipWith。 它取一个函数和两个List做参数，并把两个List交到一起(使相应的元素去调用该函数)。 如下就是我们的实现:

zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]   
zipWith' _ [] _ = []   
zipWith' _ _ [] = []   
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
看下这个类型声明，它的首个参数是个函数，取两个参数处理交叉，其类型不必相同，不过相同也没关系。 第二三个参数都是List，返回值也是个List。 第一个List中元素的类型必须是a，因为这个处理交叉的函数的第一个参数是a。 第二个List中元素的类型必为b，因为这个处理交叉的函数第二个参数的类型是b。 返回的List中元素类型为c。 如果一个函数说取一个类型为a->b->c的函数做参数，传给它个a->a->c类型的也是可以的，但反过来就不行了。 可以记下，若在使用高阶函数的时候不清楚其类型为何，就先忽略掉它的类型声明，再到ghci下用:t命令来看下haskell的类型推导.

这函数的行为与普通的zip很相似，边界条件也是相同，只不过多了个参数，即处理元素交叉的函数。它关不着边界条件什么事儿，所以我们就只留一个_ 。后一个模式的函数体与zip也很像，只不过这里是f x y而非(x,y)。 只要足够通用，一个简单的高阶函数可以在不同的场合反复使用。 如下便是我们zipWith'函数本领的冰山一角:

ghci> zipWith' (+) [4,2,5,6] [2,6,2,3]   
[6,8,7,9]   
ghci> zipWith' max [6,3,2,1] [7,3,1,5]   
[7,3,2,5]   
ghci> zipWith' (++) ["foo "，"bar "，"baz "] ["fighters"，"hoppers"，"aldrin"]   
["foo fighters","bar hoppers","baz aldrin"]   
ghci> zipWith' (*) (replicate 5 2) [1..]   
[2,4,6,8,10]   
ghci> zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]   
[[3,4,6],[9,20,30],[10,12,12]]
如你所见，一个简单的高阶函数就可以玩出很多花样。 命令式语言使用for、while、赋值、状态检测来实现功能，再包起来留个接口，使之像个函数一样调用。而函数式语言使用高阶函数来抽象出常见的模式，像成对遍历并处理两个List或从中筛掉自己不需要的结果。

接下来实现标准库中的另一个函数flip，flip简单地取一个函数作参数并返回一个相似的函数，只是它们的两个参数倒了个。

flip' :: (a -> b -> c) -> (b -> a -> c)   
flip' f = g   
    where g x y = f y x
从这类型声明中可以看出，它取一个函数，其参数类型分别为a和b，而它返回的函数的参数类型为b和a。 由于函数默认都是柯里化的，->为右结合，这里的第二对括号其实并无必要，(a -> b -> c) -> (b -> a -> c)与(a -> b -> c) -> (b -> (a -> c))等价,也与(a -> b -> c) -> b -> a -> c等价。 前面我们写了g x y = f y x，既然这样可行，那么f y x = g x y不也一样? 这一来我们可以改成更简单的写法:

flip' :: (a -> b -> c) -> b -> a -> c   
flip' f y x = f x y
在这里我们就利用了柯里函数的优势，只要调用flip' f而不带y和x，它就会返回一个俩参数倒个的函数。flip处理的函数往往都是用来传给其他函数调用，于是我们可以发挥柯里函数的优势，预先想好发生完全调用的情景并处理好返回值.

ghci> flip' zip [1,2,3,4,5] "hello"   
[('h',1),('e',2),('l',3),('l',4),('o',5)]   
ghci> zipWith (flip' div) [2,2..] [10,8,6,4,2]   
[5,4,3,2,1]
