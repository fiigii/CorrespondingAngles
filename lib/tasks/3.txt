德州区间

该怎样得到一个包含1到20之间所有数的List呢?我们完全可以用手把它全打出来，但显而易见，这并不是完美人士的方案，他们都用区间（Range）。Range是构造List方法之一，而其中的值必须是可枚举的，像1、2、3、4...字符同样也可以枚举，字母表就是A..Z所有字符的枚举。而名字就不可以枚举了，"john"后面是谁？我不知道。

要得到包含1到20中所有自然数的List，只要[1..20]即可，这与用手写[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]是完全等价的。其实用手写一两个还不是什么大事，但若是手写一个非常长的List那就一定是笨得可以了。

ghci> [1..20]   
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]   
ghci> ['a'..'z']   
"abcdefghijklmnopqrstuvwxyz"   
ghci> ['K'..'Z']   
"KLMNOPQRSTUVWXYZ"
Range很cool，允许你申明一个步长。要得到1到20间所有的偶数或者3的倍数该怎样？

ghci> [2,4..20]   
[2,4,6,8,10,12,14,16,18,20]   
ghci> [3,6..20]   
[3,6,9,12,15,18]  
仅需用逗号将前两个元素隔开，再标上上限即可。尽管Range很聪明，但它恐怕还满足不了一些人对它的期许。你就不能通过[1,2,4..100]这样的语句来获得所有2的幂。一方面是因为步长只能标明一次，另一方面就是仅凭前几项，数组的后项是不能确定的。要得到20到1的List，[20..1]是不可以的。必须得[20,19..1]。在Range中使用浮点数要格外小心！出于定义的原因，浮点数并不精确。若是使用浮点数的话，你就会得到如下的糟糕结果

ghci> [0.1, 0.3 .. 1]   
[0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999] 
我的建议就是避免在Range中使用浮点数。

你也可以不标明Range的上限，从而得到一个无限长度的List。在后面我们会讲解关于无限List的更多细节。取前24个13的倍数该怎样？恩，你完全可以[13,26..24*13]，但有更好的方法：take 24 [13,26..]。

由于Haskell是惰性的，它不会对无限长度的List求值，否则会没完没了的。它会等着，看你会从它那儿取多少。在这里它见你只要24个元素，便欣然交差。如下是几个生成无限List的函数cycle接受一个List做参数并返回一个无限List。如果你只是想看一下它的运算结果而已，它会运行个没完的。所以应该在某处划好范围。

ghci> take 10 (cycle [1,2,3])   
[1,2,3,1,2,3,1,2,3,1]   
ghci> take 12 (cycle "LOL ")   
"LOL LOL LOL "  
repeat接受一个值作参数，并返回一个仅包含该值的无限List。这与用cycle处理单元素List差不多。

ghci> take 10 (repeat 5)   
[5,5,5,5,5,5,5,5,5,5] 
其实，你若只是想得到包含相同元素的List，使用replicate会更简单，如replicate 3 10，得[10,10,10]。