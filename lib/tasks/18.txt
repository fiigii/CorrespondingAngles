折叠纸鹤

回到当初我们学习递归的情景。我们会发现处理list的许多函数都有固定的模式，通常我们会将边界条件设置为空list，再引入(x:xs)模式，对单个元素和余下的list做些事情。这一模式是如此常见，因此haskell引入了一组函数来使之简化，也就是fold。它们与map有点像，只是它们返回的是单个值。

一个fold取一个二元函数，一个初始值（我喜欢管它叫累加值）和一个需要fold（折叠）的list。这个二元函数有两个参数，即累加值和list的首项（或尾项），返回值是新的累加值。然后，以新的累加值和新的list首项调用该函数，如是继续。到list遍历完毕时，只剩下一个累加值，也就是最终的结果。

首先看下foldl函数，也叫做左折叠。它从list的左端开始折叠，用初始值和list的头部调用这二元函数，得一新的累加值，并用新的累加值与list的下一个元素调用二元函数。如是继续。

我们再实现下sum，这次用fold替代那复杂的递归：

sum' :: (Num a) => [a] -> a   
sum' xs = foldl (\acc x -> acc + x) 0 xs
测试下，一二三～

ghci> sum' [3,5,2,1]   
11

我们深入看下fold的执行过程：\acc x-> acc + x是个二元函数，0是初始值，xs是待折叠的list。一开始，累加值为0，当前项为3，调用二元函数0+3得3，作新的累加值。接着来，累加值为3，当前项为5，得新累加值8。再往后，累加值为8，当前项为2，得新累加值10。最后累加值为10，当前项为1，得11。恭喜，你完成了一次折叠(fold)！

左边的这个图表示了折叠的执行过程，一步又一步（一天又一天!）。浅棕色的数字都是累加值，你可以从中看出list是如何从左端一点点加到累加值上的。唔对对对！如果我们考虑到函数的柯里化，可以写出更简单的实现：

sum' :: (Num a) => [a] -> a   
sum' = foldl (+) 0
这个lambda函数(\acc x -> acc + x )与(+)等价。我们可以把xs等一应参数省略掉，反正调用foldl (+) 0会返回一个取list作参数的函数。通常，如果你的函数类似foo a = bar b a， 大可改为foo = bar b。有柯里化嘛。

呼呼，进入右折叠前我们再实现个用到左折叠的函数。大家肯定都知道elem是检查某元素是否属于某list的函数吧，我就不再提了（唔，刚提了）。用左折叠实现它:

elem' :: (Eq a) => a -> [a] -> Bool   
elem' y ys = foldl (\acc x -> if x == y then True else acc) False ys
好好好，这里我们有什么？起始值与累加值都是布尔值。在处理fold时，累加值与最终结果的类型总是相同的。如果你不知道怎样对待起始值，那我告诉你，我们先假设它不存在，以False开始。我们要是fold一个空list，结果就是False。然后我们检查当前元素是否为我们寻找的，如果是，就令累加值为True，如果否，就保留原值不变。若False，及表明当前元素不是。若True，就表明已经找到了。

右折叠foldr的行为与左折叠相似，只是累加值是从list的右边开始。同样，左折叠的二元函数取累加值作首个参数，当前值为第二个参数（即\acc x -> ...），而右折叠的二元函数参数的顺序正好相反（即\x acc -> ...）。这倒也正常，毕竟是从右端开始折叠。

累加值可以是任何类型，可以是数值，布尔值，甚至一个新的list。我们可以用右fold实现map函数，累加值就是个list。将map处理过的元素一个一个连到一起。很容易想到，起始值就是空list。

map' :: (a -> b) -> [a] -> [b]   
map' f xs = foldr (\x acc -> f x : acc) [] xs
如果我们用(+3)来映射[1,2,3]，它就会先到达list的右端，我们取最后那个元素，也就是3来调用(+3)，得6。追加(:)到累加值上，6:[]得[6]并成为新的累加值。用2调用(+3)，得5，追加到累加值，于是累加值成了[5,6]。再对1调用(+3)，并将结果4追加到累加值，最终得结果[4,5,6]。

当然，我们也完全可以用左折叠来实现它，map' f xs = foldl (\acc x -> acc ++ [f x]) [] xs就行了。不过问题是，使用(++)往list后面追加元素的效率要比使用(:)低得多。所以在生成新list的时候人们一般都是使用右折叠。


反转一个list，既也可以通过右折叠，也可以通过左折叠。有时甚至不需要管它们的分别，如sum函数的左右折叠实现都是十分相似。不过有个大的不同，那就是右折叠可以处理无限长度的数据结构，而左折叠不可以。将无限list从中断开执行左折叠是可以的，不过若是向右，就永远到不了头了。

所有遍历list中元素并据此返回一个值的操作都可以交给fold实现。无论何时需要遍历list并返回某值，都可以尝试下fold。因此，fold的地位可以说与map和filter并驾齐驱，同为函数式编程中最常用的函数之一。

foldl1与foldr1的行为与foldl和foldr相似，只是你无需明确提供初始值。他们假定list的首个（或末尾）元素作为起始值，并从旁边的元素开始折叠。这一来，sum函数大可这样实现：sum = foldl1 (+)。这里待折叠的list中至少要有一个元素，若使用空list就会产生一个运行时错误。不过foldl和foldr与空list相处的就很好。所以在使用fold前，应该先想下它会不会遇到空list，如果不会遇到，大可放心使用foldr1和foldl1。

为了体会fold的威力，我们就用它实现几个库函数：

maximum' :: (Ord a) => [a] -> a   
maximum' = foldr1 (\x acc -> if x > acc then x else acc)   
 
reverse' :: [a] -> [a]   
reverse' = foldl (\acc x -> x : acc) []   
 
product' :: (Num a) => [a] -> a   
product' = foldr1 (*)   
 
filter' :: (a -> Bool) -> [a] -> [a]   
filter' p = foldr (\x acc -> if p x then x : acc else acc) []   
 
head' :: [a] -> a   
head' = foldr1 (\x _ -> x)   
 
last' :: [a] -> a   
last' = foldl1 (\_ x -> x)
仅靠模式匹配就可以实现head函数和last函数，而且效率也很高。这里只是为了演示，用fold的实现方法。我觉得我们这个reverse'定义的相当聪明，用一个空list做初始值，并向左展开list，从左追加到累加值，最后得到一个反转的新list。\acc x -> x : acc有点像:函数，只是参数顺序相反。所以我们可以改成foldl (flip (:)) []。

有个理解折叠的思路：假设我们有个二元函数f，起始值z，如果从右折叠[3,4,5,6]，实际上执行的就是f 3 (f 4 (f 5 (f 6 z)))。f会被list的尾项和累加值调用，所得的结果会作为新的累加值传入下一个调用。假设f是(+)，起始值z是0，那么就是3 + (4 + (5 + (6 + 0)))，或等价的前缀形式：(+) 3 ((+) 4 ((+) 5 ((+) 6 0)))。相似，左折叠一个list，以g为二元函数，z为累加值，它就与g (g (g (g z 3) 4) 5) 6等价。如果用flip (:)作二元函数，[]为累加值（看得出，我们是要反转一个list），这就与flip (:) (flip (:) (flip (:) (flip (:) [] 3) 4) 5) 6等价。显而易见，执行该表达式的结果为[6,5,4,3]。

scanl和scanr与foldl和foldr相似，只是它们会记录下累加值的所有状态到一个list。也有scanl1和scanr1。

ghci> scanl (+) 0 [3,5,2,1]   
[0,3,8,10,11]   
ghci> scanr (+) 0 [3,5,2,1]   
[11,8,3,1,0]   
ghci> scanl1 (\acc x -> if x > acc then x else acc) [3,4,5,3,7,9,2,1]   
[3,4,5,5,7,9,9,9]   
ghci> scanl (flip (:)) [] [3,2,1]   
[[],[3],[2,3],[1,2,3]]
当使用scanl时，最终结果就是list的最后一个元素。而在scanr中则是第一个。

sqrtSums :: Int   
sqrtSums = length (takeWhile (<1000) (scanl1 (+) (map sqrt [1..]))) + 1
ghci> sqrtSums   
131   
ghci> sum (map sqrt [1..131])   
1005.0942035344083   
ghci> sum (map sqrt [1..130])   
993.6486803921487
scan可以用来跟踪fold函数的执行过程。想想这个问题，取所有自然数的平方根的和，寻找在何处超过1000？先map sqrt [1..]，然后用个fold来求它们的和。但在这里我们想知道求和的过程，所以使用scan，scan完毕时就可以得到小于1000的所有和。所得结果list的第一个元素为1，第二个就是1+根2，第三个就是1+根2+根3。若有x个和小于1000，那结果就是x+1。